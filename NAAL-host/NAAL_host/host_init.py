import sockets
import socket
import os
import threading
import paramiko
import numpy as np
import config_FPGA
import npzFile

## 초창기 ID값과 ...등    보드에 전달  초기화 
## 현재 부분은 
class host_Init(object):
 
    #fpga 보드 이름
    #시도 횟수                 (초)
    #타임아웃                  (초)
    def __init__(self, fpga_name, n_neurons, dimensions, learning_rate, socket_args={}):
        self.config =config_FPGA.Is_FPGABOAD(fpga_name)
        self.fpga_name=fpga_name      
        self.tcp_port =int(config_FPGA.config_parser(self.fpga_name, 'tcp_port'))
        self.tcp_init= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp_init.bind((config_FPGA.config_parser('host', 'ip'),8585))
        self.tcp_init.listen(1)
        print("command tcp listens ....");



        # Make SSHClient object ssh sftp 연결                                      
        self.ssh_client = paramiko.SSHClient()
        self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.ssh_info_str = ''
        self.ssh_lock = False

        # fpga data init
        self.fpga_name = fpga_name
        self.arg_data_path = os.curdir
        self.arg_data_file = ''

        self.input_dimensions = dimensions

        self.neuron_map={
            'RectifiedLinear','SpikingRectifiedLinear'
            }

        self.learning_rate =learning_rate;
        #if self.udp_port == 0:
        self.udp_port = int(np.random.uniform(low=20000, high=65535))
        
        # Set default udp socket arguments
        socket_kwargs = dict(socket_args)
        socket_kwargs.setdefault('recv_timeout', 0.1)
        
        #self.udp_socket = sockets.UDPSendReceiveSocket(
        #    listen_addr=(fpga_config.get('host', 'ip'), self.udp_port),
        #    remote_addr=(fpga_config.get(fpga_name, 'ip'), self.udp_port),
        #    **socket_kwargs)
        
    @property
    def local_data_filepath(self):
        # Full path to ensemble parameter value data file on the local system.
        # Ensemble parameter values are generated by the builder.
        return os.path.join(self.arg_data_path, self.arg_data_file)  
    
    @property
    def ssh_string(self):
       # ssh_str = ('python ' + self.config['test_script'] +' --host_ip="%s"' % config_FPGA.config_parser("host","ip")+' --tcp_port=%i' % self.tcp_port +'\n')
        ssh_str = \
            ('python ' + config_FPGA.config_parser(self.fpga_name, 'NAAL_script') +
             ' --host_ip="%s"' % config_FPGA.config_parser('host', 'ip')
           + ' --remote_ip="%s"' % config_FPGA.config_parser(self.fpga_name, 'ip')
          + ' --udp_port=%i' % self.udp_port 
          +' --tcp_port=%i' % self.tcp_port
          + ' --arg_data_file="%s/%s"' %
             (config_FPGA.config_parser(self.fpga_name, 'NAAL_tmp'),
             self.arg_data_file) + '\n')
        return ssh_str

    def connect_thread_function(self,command):
        
        remote_ip = self.config['ip']
        # Get the SSH options from the fpga_config file     
        ssh_port = self.config['ssh_port']
        ssh_user = self.config['ssh_user']
        ssh_pwd = self.config['ssh_pwd']
        #ssh key 값에 대하여 미구현 상태
        self.ssh_client.connect(remote_ip, port=ssh_port,
        username=ssh_user, password=ssh_pwd)
        #print(self.ssh_client)



        if command is "connect":
            send_str =self.ssh_string
        else :
            send_str=command

        if ssh_pwd is not None:
            # If an ssh password is provided, just use it
            self.ssh_client.connect(remote_ip, port=ssh_port,
                                    username=ssh_user, password=ssh_pwd)
        else:
            # If no password or key is specified, just use the default connect
            # (paramiko will then try to connect using the id_rsa file in the
            #  ~/.ssh/ folder)
            self.ssh_client.connect(remote_ip, port=ssh_port,
                                    username=ssh_user)



        # Send required ssh string
        print("send command ");
        print("<%s> Sending cmd to fpga board: \n%s" % (self.config['ip'],send_str), flush=True)


        # Send argument file over
        remote_data_filepath = \
            '%s/%s' % (config_FPGA.config_parser(self.fpga_name, 'NAAL_tmp'),
                       self.arg_data_file)

        print("remote_data_file path"+remote_data_filepath)

        if not os.path.exists(self.local_data_filepath):
            print("none npz file exit")
            exit()
        print("local data"+self.local_data_filepath)



        # Create sftp connection
        sftp_client = self.ssh_client.open_sftp()
        
         
        #리눅스 사용시
        if os.path.isfile(self.local_data_filepath):
            sftp_client.put(self.local_data_filepath, remote_data_filepath)
        else:
            print("error local_npz file not exist")
            exit()
        # Close sftp connection and release ssh connection lock
        
        sftp_client.close()
        os.remove(self.local_data_filepath)
        # Invoke a shell in the ssh client
        ssh_channel = self.ssh_client.invoke_shell()
        if ssh_user != 'root':
            print('<%s> Script to be run with sudo. Sudoing.' %
                  remote_ip, flush=True)
            ssh_channel.send('sudo su\n')


        ssh_channel.send(send_str)


        got_error = 0
        error_strs = []

        got_error = 0
        error_strs = []


        while True:
            data = ssh_channel.recv(256)
            if not data:

                ssh_channel.close()
                break

            self.process_ssh_output(data)
            info_str_list = self.ssh_info_str.split('\n')
            for info_str in info_str_list[:-1]:
                if info_str.startswith('Killed'):
                    print('<%s> ENCOUNTERED ERROR!' % remote_ip, flush=True)
                    got_error = 2

                if info_str.startswith('Traceback'):
                    print('<%s> ENCOUNTERED ERROR!' % remote_ip, flush=True)
                    got_error = 1
                elif got_error > 0 and info_str[0] != ' ':
                    got_error = 2

                if got_error > 0:

                    error_strs.append(info_str)
                else:
                    print('<%s> %s' % (remote_ip, info_str), flush=True)
            self.ssh_info_str = info_str_list[-1]


            if got_error == 2:
                ssh_channel.close()
                raise RuntimeError(
                    'Received the following error on the remote side <%s>:\n%s'
                    % (remote_ip, '\n'.join(error_strs)))


    def send_command(self,command):
        print("<%s> Open SSH connection" %
              self.config['ip'], flush=True)
        connect_thread = threading.Thread(target=self.connect_thread_function,
                                          args=(command,))
        connect_thread.start()



    def connect(self):
        print("<%s> Open SSH connection" %
              self.config['ip'], flush=True)
        command=0x00 # connect
   
        connect_thread = threading.Thread(target=self.connect_thread_function,
                                          args=("connect",))
        connect_thread.start()

    def process_ssh_output(self, data):
        # Clean up the data stream coming back over ssh
        str_data = data.decode('latin1').replace('\r\n', '\r')
        str_data = str_data.replace('\r\r', '\r')
        str_data = str_data.replace('\r', '\n')

        # Process and dump the returned ssh data to logger. Data (strings)
        # returned over SSH are terminated by a newline, so, keep track of
        # the data and write the data to logger only when a newline is
        # received.
        self.ssh_info_str += str_data

    #수정 할 것
    def build_pes_network(self,npz_filename):
        self.npz_filename=npz_filename
        self.arg_data_file =npz_filename

    def command_sockets_init(self):
        client_socket,addr = self.tcp_init.accept()
        self.tcp_send_sock= client_socket
        data= client_socket.recv(1024)
        print(data)
        data=str(data)
        if data.find("connect"):
            print("tcp initialization success")
        else :
            print("tcp initialization failure")
            exit()

    def send_command(self,command):
        self.tcp_send_sock.send((command).encode("utf-8"))





test=host_Init('pynq',196,196,0)
print("test ="+test.ssh_string)
test.build_pes_network("fpen_args_123456.npz")
test.connect()
test.command_sockets_init();
test.send_command("hello")

#test.connect()
#test.udp_init.recv()
#test.recv_id()     

#tcp_send= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#tcp_send.connect()                       
